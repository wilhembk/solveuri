# Solveuri

Solveuri is an open source program that was firstly created to find magic labeling (VMT) on complete graph, a research project we had to do for college.   
As we got into an intership in the LIP6 Decision team, we were invited to further study this concept, and so we enhanced the program a bunch to suits our need.  

## What does it do ?

Solveuri uses an heuristic approach to solve magic and antimagic labelling of graphs (mainly VAT or VMT), it can solve pretty much any type of magic labelling relatively quickly.  
However, if it can't find a solution, this is not a guarantee that the magic labeling does not exists.  

## How to use

It's only usable on Unix-like file system.

To compile the program
```
git clone https://github.com/wilhembk/solveuri.git
cd solveuri
make all
```
To remove every binaries you can execute `make clean`

To run the program, start by typing `./solveuri`, followed with the wanted parameters.
All the parameters are described in this helptext : 
```
Generate solutions of a specified graph.

Parameters c, a and r are incompatible together
     -h    : Print this help text
     -e    : Open the graph editor. If file is specified, only edits the first graph
     -c    : Solve a complete graph. Expected option : size of the complete graph
     -a    : Solve an antiprism. Expected option : size of the antiprism
     -r    : Solve a (a0,d0)-(a1,d1)-VAT of a rectangle. Expected options : width of the rectangle, height of the rectangle, d0, d1.
     -f    : Solve the graphs of the filename in option. Expected option : the name of a file generated by geng and parsed with showg -e
     -l    : Relabel the graph with consecutive elements before solve 
     -s    : Save the solutions in a dotfile. Expected option : name of the directory where to save the graphs
     -p    : Print the solutions in the shell
     -n    : Number of tries. Expected option: an integer. Default is 1 
     -t    : The maximum number of loop in the resolution. Expected option: an integer. Default is 200'000 
     -M    : The magic constant goal. If not precised, it will find any possible magic constant
     -S    : The step of the VAT. If not precised, it solves a VMT. If -1, it will find any possible step
     -D    : Found a labelling where all the weights are different
     -T    : The label values that are not permited to permute. Expected option : all the concerned labels separated by spaces 
```



### Example usage:

Solve a VMT for a complete graph of size 7 with any magic constant :
```
./solveuri -c 7
```
Solve a VMT for a complete graph of size 5 and a magic constant of 40, then print it in the shell:

```
./solveuri -c 5 -M 40 -p
```
Solve a VAT for an antiprism of size 6, any magic constant and a antimagic step of 3, and do it 10 times:

```
./solveuri -a 6 -S 3 -n 10
```
Solve a VAT for the graph in the file "graph.dot", a magic constant of 105, any antimagic step, and then save it in the "Graph" directory:

```
./solveuri -f graph.dot -M 105 -S -1 -s Graphs
```
Solve a (a_0,1)-(a_1,1)VAT for a 10,2 rectangle and setup the timeout to 20 maximum loops, and try it 1000 times:

```
./solveuri -r 10 1 2 1 -t 20 -n 1000
```
Open the graph editor, then solve the graph created as a VMT for any magic constant without ever moving the labels 10,12,14 and 16:

```
./solveuri -e -T 10 12 14 16
 ```

Now you are a wizard, have fun !


### About the editor

If you want to make quick adjustments to a graph, or simply create a new one you can use the editor by specifying the parameter `-e`.  

Firstly, you will be prompted to start with a specific graph. From there, you can open a file with the `open`  command, or you can generate a new graph from existing presets (complete graph, complete bipartite, or antiprisms) or from scratch with the `begin` command.    
Be aware that, due to the spcificity of our graph structure, the program always needs to know the number of vertices, before creating edges.    

Once a graph is open, you can start editing, using the name of the elements to select them. Here are the list of commands with examples:

#### `link` command
**Usage** : `link <v1> <label> <v2> [<label> <vi>]`  Allows you to link a vertex with the others.
> The first vertex you will specify will be linked to all the other vertices in the list. The label you give, will be the label of the edge.  

The command below links the vertex named `v0` with the vertices `v1` , `v2`  and `v3`. The edge `v0 -- v1` is labelled `1`, `v0 -- v2` is labelled `2` and `v0 -- v1` is labelled `3`   
```
link v0 1 v1 2 v2 3 v3
```

#### `unlink` command
**Usage** : `unlink <v1> <v2> [<vi>]`  Allows you to remove edges from a vertex.
> The first vertex you will specify will be unlink to all the others. Just like the command `link`  

The command below removes the edges `v0 -- v1`, `v0 -- v2` and `v0 -- v3`
```
unlink v0 v1 v2 v3
```

#### `label` command
**Usage** : `label <elem1> <label> [<elemi> <label>]`  Allows you to change labels of existing elements
> The element you specify will receive the label you give right after

The command below sets the label of `v0` to `3` and `e3` to `5` 
```
label v0 3 e3 5
```

#### `relabel` command
**Usage** : `relabel [edges]`  Allows you make all the labels consecutive
> If you specify `edges` all the labels of the edges will be consecutive

```
relabel
relabel edges
```

#### `solve` command
**Usage** : `solve`  Starts the graph solve

#### `save` command
**Usage** : `save <filename>`  Saves the graph in a dot file format
> Be sure to specify the `.dot`  file extension

## For the developpers

This section will present the principle of the algorithm, then how you can manipulate the main functions, or add anything you need.  

The heuristic method is based on an evaluation of a graph, called an objetive function. This function must recpect some properties.  

It must take at least the graph in argument, and must return 0 if the graph has the caracteristics you want.  

Example :
```
float magicFormulaUnknownConst(Solver* s) {
    float res = 0;
    int nb = s->g->nbv;

    int weights[nb];

    int temp;
    for (int i = 0; i < nb; i++) {
        temp = (s->tab[i]->v->label);
        for (int j = 0; j < s->tab[i]->size; j++) {
            temp += s->tab[i]->issuedEdges[j]->label;
        }
        weights[i] = temp;
        res += weights[i];
    }

    float avg = res / nb;
    res = 0;
    for (int i = 0; i < nb; i++) {
        res += (weights[i] - avg) * (weights[i] - avg);
    }
    return res;
}
```
This function calculated the average value of the weights of the graph g, and return the variance of the weights around this value.  
If all the weights are the same, and only in this case, the function returns 0.  
This functions will define the kind graph you want to reach, so feel free to create one if you want to solve a specific problem.  

The algorithm will call those functions, and return the graph when the objective function will reach 0.  
It works with permutations. Depending of the section, it will permute some labels, and check if the objective function if lower with this permution, and repeat it until it founds a solution.  
In the main part, it permute the labels between a vertex and the edges issued from this vertex.  
When none of those permutations improve the objective function, it will permute the labels of all the vertex.  
When none of those permutations improve the objective function, it will permute all the labels between one vertex and one edge.  
When none of those permutations improve the objective function, it will permute the labels of all the edges.  
When none of those permutations improve the objective function, then the algorithm has reach a local minimum, so it permutes randomly two labels, even if it highers the objective function.  











## References

To make this program work, we read research papers that particularly helped and that you can find here  

McKay, B.D. and Piperno, A., Practical Graph Isomorphism, II, Journal of Symbolic Computation, 60 (2014), pp. 94-112, https://doi.org/10.1016/j.jsc.2013.09.003   
Wallis, W. D. (2012). Magic graphs. Springer Science & Business Media.
