#include "Editor.h"
#include "Graph.h"
#include "GraphParser.h"
#include "Rectangle.h"
#include "Solver.h"
#include "Utils.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

extern int timeout;

#define HELPTEXT \
    "Generate solutions of a specified graph.\n\
\n\
Parameters c, a and r are incompatible together\n\
     -h    : Print this help text\n\
     -e    : Open the graph editor. If file is specified, only edits the first graph\n\
     -c    : Solve a complete graph. Expected option : size of the complete graph\n\
     -a    : Solve an antiprism. Expected option : size of the antiprism\n\
     -r    : Solve a (a0,d0)-(a1,d1)-VAT of a rectangle. Expected options : width of the rectangle, height of the rectangle, d0, d1.\n\
     -f    : Solve the graphs of the filename in option. Expected option : the name of a file generated by geng and parsed with showg -e\n\
     -l    : Relabel the graph with consecutive elements before solve \n\
     -s    : Save the solutions in a dotfile. Expected option : name of the directory where to save the graphs\n\
     -p    : Print the solutions in the shell\n\
     -n    : Number of tries. Expected option: an integer. Default is 1 \n\
     -t    : The maximum number of loop in the resolution. Expected option: an integer. Default is 200'000 \n\
     -M    : The magic constant goal. If not precised, it will find any possible magic constant\n\
     -S    : The step of the VAT. If not precised, it solves a VMT. If -1, it will find any possible step\n\
     -D    : Found a labelling where all the weights are different\n\
     -T    : The label values that are not permited to permute. Expected option : all the concerned labels separated by spaces \n\
See README for examples and better details\n"
int main(int argc, char** argv) {

    srand(time(NULL));

    int helpFlag = 0;
    int editorFlag = 0;
    int completeFlag = 0;
    int antiprismFlag = 0;
    int rectangleFlag = 0;
    int fileFlag = 0;

    int magicFlag = 0;
    int stepFlag = 0;
    int diffFlag = 0;

    int l = 0;
    int L = 0;
    int step_l = 0;
    int step_L = 0;
    int antiprism_size = 0;
    int complete_size = 0;
    char* directory = NULL;
    int pflag = 0;
    int nb = 1;
    char* filename = NULL;
    int magic_constant = 0;
    int step = 0;
    int relabelFlag = 0;
    char c;
    int* taboo = NULL;
    int taboo_size = 0;
    int a = 0;
    int d = 0;

    char buff[BUFFER_SIZE];

    while ((c = getopt(argc, argv, "her:a:c:f:s:pn:M:S:lDt:T:")) != -1)
        switch (c) {
        case 'h':
            helpFlag = 1;
            break;
        case 'e':
            editorFlag = 1;
            break;
        case 'r':
            rectangleFlag = 1;
            l = atoi(optarg);
            L = atoi(argv[optind]);
            optind++;
            step_l = atoi(argv[optind]);
            optind++;
            step_L = atoi(argv[optind]);
            optind++;
            break;
        case 'a':
            antiprismFlag = 1;
            antiprism_size = atoi(optarg);
            break;
        case 'c':
            completeFlag = 1;
            complete_size = atoi(optarg);
            break;
        case 'f':
            fileFlag = 1;
            filename = optarg;
            break;
        case 's':
            directory = optarg;
            break;
        case 'p':
            pflag = 1;
            break;
        case 'n':
            nb = atoi(optarg);
            break;
        case 'M':
            magicFlag = 1;
            magic_constant = atoi(optarg);
            break;
        case 'S':
            stepFlag = 1;
            step = atoi(optarg);
            break;
        case 'l':
            relabelFlag = 1;
            break;
        case 'D':
            diffFlag = 1;
            break;
        case 't':
            timeout = atoi(optarg);
            break;
        case 'T':
            // optarg is the first integer after -t
            taboo = malloc(sizeof(int) * (argc - optind + 1));
            if (taboo == NULL) {
                fprintf(stderr, "Memory allocation failed. Exiting...\n");
                exit(EXIT_FAILURE);
            }

            // Add optarg as first integer
            taboo[taboo_size++] = atoi(optarg);

            // Read all following args until one begining with '-'
            while (optind < argc && argv[optind][0] != '-') {
                taboo[taboo_size++] = atoi(argv[optind]);
                optind++;
            }
            break;
        case '?':
            if (optopt == 'f' || optopt == 'n' || optopt == 'M' ||
                optopt == 'S' || optopt == 'c' || optopt == 's' ||
                optopt == 't' || optopt == 'r')
                fprintf(stderr, "Option -%c requires an argument.  Use ./solveuri -h to see more detailed instructions.\n", optopt);
            else if (isprint(optopt))
                fprintf(stderr, "Unknown option `-%c'. Use ./solveuri -h to see more detailed instructions.\n", optopt);
            else fprintf(stderr, "Unknown option character `\\x%x'.  Use ./solveuri -h to see more detailed instructions.\n", optopt);
            return 1;
        default:
            abort();
        }

    // Checking incompatible flags
    if (completeFlag + antiprismFlag + rectangleFlag + fileFlag > 1) {
        fprintf(stderr, "Incompatible parameters, you can only create one graph, or open one file\n"
                        "Use ./solveuri -h to see more detailed instructions\n");
        return 1;
    }

    if ((magicFlag || stepFlag) && diffFlag) {
        fprintf(stderr, "Incompatible parameters, you cannot search only for different weights,"
                        "and ask for a specific step or magic constant at the same time !\n"
                        "Use ./solveuri -h to see more detailed instructions\n");
        return 1;
    }

    if (rectangleFlag && editorFlag) {
        fprintf(stderr, "Incompatible parameters, you cannot edit a rectangle in the editor\n"
                        "Use ./solveuri -h to see more detailed instructions\n");
        return 1;
    }

    if (helpFlag) {
        printf("%s", HELPTEXT);
        return 0;
    }

    // Rectangles logic is different
    if (rectangleFlag) {
        if (l <= 0 || L <= 0) {
            fprintf(stderr, "Invalid rectangle size specified,"
                            " strictly positive numbers are required\n");
            return 1;
        }

        Rectangle* r = createRectangle("Rectangle", l, L);
        Rectangle* solvedRect;
        for (int cpt = 1; cpt < nb + 1; cpt++) {

            int const_l;
            int const_L;
            solvedRect = solveAntiMagicRect(r, step_l, step_L, &const_l, &const_L);

            if (!solvedRect) { continue; }

            if (pflag) { printRectangle(r, 1); }

            if (directory) {
                sprintf(buff, "%s/Rectangle_(%d,%d)-(%d,%d)-Antimagic_n%d.dot",
                        directory, const_l, step_l, const_L, step_L, cpt);
                generateDotFile(buff, r->g, 0);
            }
            freeRectangle(r);
            r = createRectangle("Rectangle", l, L);
        }
        return 0;
    }

    // We retrieve file extension so that dotFile are treated differently
    char name[BUFFER_SIZE];
    char ext[BUFFER_SIZE];
    if (filename) {
        sscanf(filename, "%[^.].%s", name, ext);
    }

    // We will solve immediatly solve, no editor required
    if (filename && !editorFlag) {
        CellGraph* gl;
        Graph* g;
        Graph* init;
        Solver* s;
        if (strcmp(ext, "dot") != 0) {
            CellGraph* gl = parseAllGraphs(filename)->head;

            while (gl) {

                for (int cpt = 1; cpt < nb + 1; cpt++) {
                    g = cloneGraph(gl->g);

                    relabelGraph(g);

                    if (diffFlag) {
                        s = attemptSolve(6, g, 0, 0, 0, 0, taboo, taboo_size);
                    } else if (step == 0) {
                        if (magic_constant == 0) {
                            s = attemptSolve(2, g, 0, 0, 0, 0, taboo,
                                             taboo_size);
                        } else {
                            s = attemptSolve(0, g, magic_constant, 0, 0, 0,
                                             taboo, taboo_size);
                        }
                    } else if (step == -1) {
                        if (magic_constant == 0) {
                            s = attemptSolve(4, g, 0, 0, 0, 0, taboo,
                                             taboo_size);
                            ;
                        } else {
                            s = attemptSolve(5, g, magic_constant, 0, 0, 0,
                                             taboo, taboo_size);
                        }
                    } else {
                        if (magic_constant == 0) {
                            s = attemptSolve(3, g, magic_constant, 0, step, 0,
                                             taboo, taboo_size);
                            ;
                        } else {
                            s = attemptSolve(0, g, magic_constant, 0, step, 0,
                                             taboo, taboo_size);
                        }
                    }
                    if (!s) { continue; }
                    g = s->g;
                    if (pflag) { printGraph(g); }
                    if (strcmp(directory, "")) {
                        if (diffFlag) {
                            sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                                    init->name, cpt);
                        } else if (step == 0) {
                            sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot",
                                    directory, gl->g->name, getMagicConst(g),
                                    cpt);
                        } else {
                            getAntimagicConst(s, &a, &d);
                            sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot",
                                    directory, gl->g->name, a, d,
                                    cpt);
                        }
                        generateDotFile(buff, g, 0);
                    }
                }
                gl = gl->nxt;
            }
        } else {
            init = getFromDotFile(filename);
            for (int cpt = 1; cpt < nb + 1; cpt++) {
                g = cloneGraph(init);
                if (relabelFlag) { relabelGraph(g); }
                if (diffFlag) {
                    s = attemptSolve(6, g, 0, 0, 0, 0, taboo, taboo_size);
                } else if (step == 0) {
                    if (magic_constant == 0) {
                        s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
                    } else {
                        s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                         taboo_size);
                    }
                } else if (step == -1) {
                    if (magic_constant == 0) {
                        s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);

                    } else {
                        s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                         taboo_size);
                    }
                } else {
                    if (magic_constant == 0) {
                        s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                         taboo_size);
                        ;
                    } else {
                        s = attemptSolve(0, g, magic_constant, 0, step, 0,
                                         taboo, taboo_size);
                    }
                }
                if (!s) { continue; }
                g = s->g;
                if (pflag) { printGraph(g); }
                if (strcmp(directory, "")) {
                    if (diffFlag) {
                        sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                                init->name, cpt);
                    } else if (step == 0) {
                        sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot", directory,
                                init->name, getMagicConst(g), cpt);
                    } else {
                        getAntimagicConst(s, &a, &d);
                        sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot",
                                directory, init->name, a, d, cpt);
                    }
                    generateDotFile(buff, g, 0);
                }
            }
        }
        return 0;
    }

    Graph* toSolve = NULL;

    if (completeFlag) {
        if (complete_size <= 0) {
            fprintf(stderr, "Invalid parameters, the order of the graph must be a strictly positive integer\n"
                            "Use ./solveuri -h to see more detailed instructions \n");
            return 1;
        }
        toSolve = createCompleteGraph(complete_size);
    }
    if (antiprismFlag) {
        if (antiprism_size <= 0) {
            fprintf(stderr, "Invalid parameters, the order of the graph must be a strictly positive integer\n"
                            "Use ./solveuri -h to see more detailed instructions \n");
            return 1;
        }
        toSolve = createAntiprism("Antiprism", antiprism_size);
    }
    if (filename && editorFlag) {
        if (strcmp(ext, "dot") == 0) {
            toSolve = getFromDotFile(filename);
        } else {
            GraphList* gl = parseAllGraphs(filename);
            toSolve = gl->head->g;
            freeFromCell(gl->head->nxt);
            free(gl);
        }
    }

    if (editorFlag) toSolve = startEditor(argc, argv, toSolve);

    if (!toSolve) {
        fprintf(stderr, "Invalid parameters, you need to specify a graph to solve ! "
                        "\nUse ./solveuri -h to see more detailed instructions \n");
        return 1;
    }

    Graph* g;
    Solver* s;
    for (int cpt = 1; cpt < nb + 1; cpt++) {
        g = cloneGraph(toSolve);
        if (relabelFlag) { relabelGraph(g); }
        if (diffFlag) {
            s = attemptSolve(6, g, 0, 0, 0, 0, taboo, taboo_size);
        } else if (step == 0) {
            if (magic_constant == 0) {
                s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
            } else {
                s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                 taboo_size);
            }
        } else if (step == -1) {
            if (magic_constant == 0) {
                s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);
                ;
            } else {
                s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                 taboo_size);
            }
        } else {
            if (magic_constant == 0) {
                s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                 taboo_size);
                ;
            } else {
                s = attemptSolve(0, g, magic_constant, 0, step, 0, taboo,
                                 taboo_size);
            }
        }
        if (!s) { continue; }
        g = s->g;
        if (pflag) { printGraph(g); }
        if (directory) {
            if (diffFlag) {
                sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                        toSolve->name, cpt);
            } else if (step == 0) {
                sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot", directory,
                        toSolve->name, getMagicConst(g), cpt);
            } else {
                getAntimagicConst(s, &a, &d);
                sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot", directory,
                        toSolve->name, a, d, cpt);
            }
            generateDotFile(buff, g, 0);
        }
    }
    return 0;
}
