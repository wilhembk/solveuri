#include "Editor.h"
#include "Graph.h"
#include "GraphParser.h"
#include "Solver.h"
#include "Utils.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

extern int timeout;

#define HELPTEXT                                                               \
    " Generate solutions of a specified graph.\n\
\n\
Use only one pameter between e,c,a,r and f.\n\
     -h    : Print this help text\n\
     -e    : Open the graph editor\n\
     -c    : Solve a complete graph. Expected option : size of the complete graph\n\
     -a    : Solve an antiprism. Expected option : size of the antiprism\n\
     -r    : Solve a (a0,d0)-(a1,d1)-VAT of a rectangle. Expected options : width of the rectangle, height of the rectangle, d0, d1.\n\
     -f    : Solve the graphs of the filename in option. Expected option : the name of a file generated by geng and parsed with showg -e\n\
     -s    : Save the solutions in a dotfile. Expected option : name of the directory where to save the graphs\n\
     -p    : Print the solutions in the shell\n\
     -n    : Number of tries. Expected option: an integer. Default is 1 \n\
     -t    : The maximum number of loop in the resolution. Expected option: an integer. Default is 200'000 \n\
     -M    : The magic constant goal. If not precised, it will find any possible magic constant\n\
     -S    : The step of the VAT. If not precised, it solves a VMT. If -1, it will find any possible step\n\
     -D    : Found a labelling where all the weights are different\n\
     -T    : The label values that are not permited to permute. Expected option : all the concerned labels separated by spaces \n\
  See program text for much more information.\n"
int main(int argc, char** argv) {
    srand(time(NULL));
    int l = 0;
    int L = 0;
    int eflag = 0;
    int step_l = 0;
    int step_L = 0;
    int antiprism_size = 0;
    int complete_size = 0;
    int hflag = 0;
    char directory[BUFFER_SIZE] = "";
    int pflag = 0;
    int nb = 1;
    char*  filename = NULL;
    int magic_constant = 0;
    int step = 0;
    int lflag = 0;
    char c;
    int* taboo = NULL;
    int taboo_size = 0;
    int Dflag=0;
    int a=0;
    int d=0;

    char buff[BUFFER_SIZE];

    while ((c = getopt(argc, argv, "her:a:c:f:s:pn:M:S:lDt:T:")) != -1)
        switch (c) {
        case 'h':
            hflag = 1;
            break;
        case 'e':
            eflag = 1;
            break;
        case 'r':
            l = atoi(optarg);
            L = atoi(argv[optind]);
            optind++;
            step_l = atoi(argv[optind]);
            optind++;
            step_L = atoi(argv[optind]);
            optind++;
            break;
        case 'a':
            antiprism_size = atoi(optarg);
            break;
        case 'c':
            complete_size = atoi(optarg);
            break;
        case 'f':
            filename = optarg;
            break;
        case 's':
            strcpy(directory , (char*)optarg);
            break;
        case 'p':
            pflag = 1;
            break;

        case 'n':
            nb = atoi(optarg);
            break;
        case 'M':
            magic_constant = atoi(optarg);
            break;
        case 'S':
            step = atoi(optarg);
            break;
        case 'l':
            lflag = 1;
            break;
        case 'D':
            Dflag = 1;
            break;
        case 't':
            timeout = atoi(optarg);
            break;
        case 'T':
            // optarg is the first integer after -t
            taboo = malloc(sizeof(int) * (argc - optind + 1));
            if (taboo == NULL) {
                fprintf(stderr, "Erreur d'allocation m√©moire\n");
                exit(EXIT_FAILURE);
            }

            // Add optarg as first integer
            taboo[taboo_size++] = atoi(optarg);

            // Read all following args until one begining with '-'
            while (optind < argc && argv[optind][0] != '-') {
                taboo[taboo_size++] = atoi(argv[optind]);
                optind++;
            }
            break;
        case '?':
            if (optopt == 'f' || optopt == 'n' || optopt == 'M' ||
                optopt == 'S' || optopt == 'c' || optopt == 's' ||
                optopt == 't' || optopt == 'r')
                fprintf(stderr, "Option -%c requires an argument.  Use ./solveuri -h to see more detailed instructions.\n", optopt);
            else if (isprint(optopt))
                fprintf(stderr, "Unknown option `-%c'. Use ./solveuri -h to see more detailed instructions.\n", optopt);
            else fprintf(stderr, "Unknown option character `\\x%x'.  Use ./solveuri -h to see more detailed instructions.\n", optopt);
            return 1;
        default:
            abort();
        }
    if (hflag) { printf("%s", HELPTEXT); }

    if (eflag) {
        Graph* init = startEditor(argc, argv);
        Graph* g;
        Solver* s;
        for (int cpt = 1; cpt < nb + 1; cpt++) {
            g = cloneGraph(init);
            if (lflag) { relabelGraph(g); }
            if (Dflag){
                s=attemptSolve(6,g,0,0,0,0,taboo,taboo_size);
            }
            else if (step == 0) {
                if (magic_constant == 0) {
                    s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else if (step == -1) {
                if (magic_constant == 0) {
                    s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);
                    ;
                } else {
                    s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else {
                if (magic_constant == 0) {
                    s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                    ;
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                }
            }
            if (!s) { continue; }
            g = s->g;
            if (pflag) { printGraph(g); }
            if (strcmp(directory,"")) {
                if (Dflag){
                    sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                            init->name, cpt);
                }
                else if (step == 0) {
                    sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot", directory,
                            init->name, getMagicConst(g), cpt);
                } else {
                    getAntimagicConst(s,&a,&d);
                    sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot", directory,
                            init->name, a,d, cpt);
                }
                generateDotFile(buff, g, 0);
            }
        }
    } else if (filename) {
        
        char name[BUFFER_SIZE];
        char ext[BUFFER_SIZE];
        sscanf(filename, "%[^.].%s", name, ext);
        
        CellGraph* gl;
        Graph* g;
        Graph* init;
        Solver* s;
        if (strcmp(ext, "txt") == 0) {
            CellGraph* gl = parseAllGraphs(filename)->head;

            while (gl) {

                for (int cpt = 1; cpt < nb + 1; cpt++) {
                    g = cloneGraph(gl->g);
                    

                    relabelGraph(g);

                    if (Dflag){
                        s=attemptSolve(6,g,0,0,0,0,taboo,taboo_size);
                        }
                    else if (step == 0) {
                        if (magic_constant == 0) {
                            s = attemptSolve(2, g, 0, 0, 0, 0, taboo,
                                             taboo_size);
                        } else {
                            s = attemptSolve(0, g, magic_constant, 0, 0, 0,
                                             taboo, taboo_size);
                        }
                    } else if (step == -1) {
                        if (magic_constant == 0) {
                            s = attemptSolve(4, g, 0, 0, 0, 0, taboo,
                                             taboo_size);
                            ;
                        } else {
                            s = attemptSolve(5, g, magic_constant, 0, 0, 0,
                                             taboo, taboo_size);
                        }
                    } else {
                        if (magic_constant == 0) {
                            s = attemptSolve(3, g, magic_constant, 0, step, 0,
                                             taboo, taboo_size);
                            ;
                        } else {
                            s = attemptSolve(0, g, magic_constant, 0, step, 0,
                                             taboo, taboo_size);
                        }
                    }
                    if (!s) { continue; }
                    g = s->g;
                    if (pflag) { printGraph(g); }
                    if(strcmp(directory,"")) {
                        if (Dflag){
                            sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                            init->name, cpt);
                        }
                        else if (step == 0) {
                            sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot",
                                    directory, gl->g->name, getMagicConst(g),
                                    cpt);
                        } else {
                            getAntimagicConst(s,&a,&d);
                            sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot",
                                    directory, gl->g->name, a,d,
                                    cpt);
                        }
                        generateDotFile(buff, g, 0);
                    }
                }
                gl = gl->nxt;
            }
        }
        if (strcmp(ext, "dot") == 0) {
            init = getFromDotFile(filename);
            for (int cpt = 1; cpt < nb + 1; cpt++) {
                g = cloneGraph(init);
                if (lflag) { relabelGraph(g); }
                if (Dflag){
                    s=attemptSolve(6,g,0,0,0,0,taboo,taboo_size);
                }
                else if (step == 0) {
                    if (magic_constant == 0) {
                        s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
                    } else {
                        s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                         taboo_size);
                    }
                } else if (step == -1) {
                    if (magic_constant == 0) {
                        s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);
                        
                    } else {
                        s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                         taboo_size);
                    }
                } else {
                    if (magic_constant == 0) {
                        s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                         taboo_size);
                        ;
                    } else {
                        s = attemptSolve(0, g, magic_constant, 0, step, 0,
                                         taboo, taboo_size);
                    }
                }
                if (!s) { continue; }
                g = s->g;
                if (pflag) { printGraph(g); }
                if (strcmp(directory,"")) {
                    if (Dflag){
                        sprintf(buff, "%s/Graph_%s_n%d.dot", directory,
                            init->name, cpt);
                    }
                    else if (step == 0) {
                        sprintf(buff, "%s/Graph_%s_%d-VMT_n%d.dot", directory,
                                init->name, getMagicConst(g), cpt);
                    } else {
                        getAntimagicConst(s,&a,&d);
                        sprintf(buff, "%s/Graph_%s_(%d,%d)-VAT_n%d.dot",
                                directory, init->name, a,d, cpt);
                    }
                    generateDotFile(buff, g, 0);
                }
            }
        }
    }

    else if (complete_size > 0) {
        Graph* g = createCompleteGraph(complete_size);
        Solver* s;

        for (int cpt = 1; cpt < nb + 1; cpt++) {
            relabelGraph(g);
            if (Dflag){
                s=attemptSolve(6,g,0,0,0,0,taboo,taboo_size);
            }
            else if (step == 0) {
                if (magic_constant == 0) {
                    s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else if (step == -1) {
                if (magic_constant == 0) {
                    s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);
                    ;
                } else {
                    s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else {
                if (magic_constant == 0) {
                    s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                    ;
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                }
            }
            if (!s) { continue; }
            g = s->g;
            if (pflag) { printGraph(g); }
            if (strcmp(directory,"")) {
                if (Dflag){
                    sprintf(buff, "%s/All_Different_Complete_Graph_n%d.dot", directory, cpt);
                }else if (step == 0) {
                    sprintf(buff, "%s/Complete_Graph_%d-VMT_n%d.dot", directory,
                            getMagicConst(g), cpt);
                } else {
                    getAntimagicConst(s,&a,&d);
                    sprintf(buff, "%s/Complete_Graph_(%d,%d)-VAT_n%d.dot",
                            directory,a,d, cpt);
                }
                generateDotFile(buff, g, 0);
            }
        }

    } else if (antiprism_size > 0) {
        Graph* g = createAntiprism("Antiprism", antiprism_size);
        Solver* s;

        for (int cpt = 1; cpt < nb + 1; cpt++) {
            relabelGraph(g);
            if (Dflag){
                s=attemptSolve(6,g,0,0,0,0,taboo,taboo_size);
            }
            else if (step == 0) {
                if (magic_constant == 0) {
                    s = attemptSolve(2, g, 0, 0, 0, 0, taboo, taboo_size);
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else if (step == -1) {
                if (magic_constant == 0) {
                    s = attemptSolve(4, g, 0, 0, 0, 0, taboo, taboo_size);
                    ;
                } else {
                    s = attemptSolve(5, g, magic_constant, 0, 0, 0, taboo,
                                     taboo_size);
                }
            } else {
                if (magic_constant == 0) {
                    s = attemptSolve(3, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                    ;
                } else {
                    s = attemptSolve(0, g, magic_constant, 0, step, 0, taboo,
                                     taboo_size);
                }
            }
            if (!s) { continue; }
            g = s->g;
            if (pflag) { printGraph(g); }
            if (strcmp(directory,"")) {
                if (Dflag){
                    sprintf(buff, "%s/All_Different_Antiprism_Graph_n%d.dot", directory, cpt);
                }else if (step == 0) {
                    sprintf(buff, "%s/Antiprism_Graph_%d-VMT_n%d.dot",
                            directory, getMagicConst(g), cpt);
                } else {
                    getAntimagicConst(s,&a,&d);
                    sprintf(buff, "%s/Antiprisme_Graph_(%d,%d)-VAT_n%d.dot",
                            directory, a,d, cpt);
                }
                generateDotFile(buff, g, 0);
            }
        }

    } else if (L > 0) {
        Rectangle* r = createRectangle("Rectangle", l, L);
        Solver* s;
        int sum = 0;
        for (int i = 1; i <= r->g->nbv + r->g->nbe; i++) {
            sum += i;
        }
        int const_l =
            ((l * L) * (l * L + 1) / (2 * l)) - ((l - 1) * step_l / 2);
        int const_L =
            ((l * L) * (l * L + 1) / (2 * L)) - ((L - 1) * step_L / 2);
        printf("%d %d %d %d %d %d\n", l, L, const_l, const_L, step_l, step_L);

        for (int cpt = 1; cpt < nb + 1; cpt++) {

            s = attemptSolve(1, r->g, const_l, const_L, step_l, step_L, NULL,
                             0);

            if (!s) { continue; }
            if (pflag) { printRectangle(r, 1); }
            if (strcmp(directory,"")) {
                sprintf(buff, "%s/Rectangle_(%d,%d)-(%d,%d)-Antimagic_n%d.dot",
                        directory, const_l, step_l, const_L, step_L, cpt);
                generateDotFile(buff, r->g, 0);
            }
            freeSolver(s, 1);
            r = createRectangle("Rectangle", l, L);
        }
    }

    for (int index = optind; index < argc; index++)
        printf("Non-option argument %s.  Use ./solveuri -help to see more detailed instructions.\n", argv[index]);
    return 0;
}
